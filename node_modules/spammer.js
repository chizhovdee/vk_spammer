var util = require('util');
var EventEmitter = require('events').EventEmitter;
var VK = require('vk');
var MongoClient = require('mongodb').MongoClient;

var login_timeout = 1000; // 1000 - одна секунда
var get_group_members_timout = 1000;
var get_users_timeout = 1000;
var add_to_friends_timeout = 5000; // 60 секунд
var restart_timeout = 1 * 60000; // минут
var add_to_frends_next_timeout = 10 * 60000 // минут

var application;
var db;
var queue_authorization = 0;
var queue_group = 0;

var captcha_limit = 5;

var Spammer = function (){}

Spammer.prototype.start = function() {
  application = window.application;

  application.primaryLog('Приложение запущено!');

  step1(); // Вызов первого шага
}

function step1(){
  /*
  *  В этом шаге мы подключаемся к базе данных, делаем предварительный выход из Vk,
  *  рекурсивно запрашиваем всех участников главной группы и синхронизируем их с базой данных
  *
  */

  application.primaryLog('<strong>Запускаем шаг 1</strong>');

  connectToDb(function(err, response){
    db = response;

    application.secondaryLog('Подключение к базе данных прошло успешно!');

    logOutAndLogin(null, function(response){
      application.secondaryLog('Начинаем синхронизацию участников группы <strong>' + global.main_group + '</strong> с базой данных...');

      // как только прошла первая авторизация, синхронизируем данные с базой
      synchronizeGroupMembersWithDb(global.main_group, function(){
        // вызов второго шага
        step2();
      });
    });
  });
}

function step2(){
  /*
  *
  *
  */

  application.primaryLog('<strong>Запускаем шаг 2</strong>');

  synchronizeFriendsWithDb(function(){
    step3();
  });
}

function step3(){
  /*
  *
  *
  */

  application.primaryLog('<strong>Запускаем шаг 3</strong>');

  parseGroupsForAddingMembersToFriends(function(){
    //
    console.log('Здесь пока выбираем новую группу, а может и нет!');
  });
}



function synchronizeGroupMembersWithDb(group_id, callback){

  var onGroupMembersReceived = function(response, count){
    synchronizeUsersWithDb(response.users, function(){
      if(response.count > response.offset){
        setTimeout(function(){
          getGroupMembers(main_group, count, response.offset, onGroupMembersReceived);
        }, get_group_members_timout);

      } else {
        application.primaryLog('Все участники группы обработаны.');

        callback();
      }
    });
  }

  getGroupMembers(group_id, 1000, 0, onGroupMembersReceived);
}

function getGroupMembers(group_id, count, offset, callback){
  if(!count) count = 1000;
  if(!offset) offset = 0;

  application.primaryLog('Получение участников группы <strong>' + group_id + '</strong>...');

  var options = {
    gid: group_id,
    access_token: global.current_user.access_token,
    count: count,
    sort: 'time_desc'
  }

  if(offset > 0){
    _.extend(options, {offset: offset});
  }

  VK.request('groups.getMembers',
    options,
    function(error, response){
      if(error){
        vkMethodRequestError(error, 'Произошла ошибка получения данных группы <strong>' + group_id + '</strong>');

      } else {
        application.secondaryLog('Получение ' + (offset + response.users.length) + ' из ' + response.count + ' участников группы <strong>' + group_id + '</strong> прошло успешно');

        _.extend(response, {offset: offset + response.users.length});

        callback(response, count);
      }
    }
  );
}

function logOutAndLogin(onLogOutCallback, onLoginCallback){
  vkLogout(function(response){
    setTimeout(function(){
      vkLogin(onLoginCallback);
    }, login_timeout);
  });
}

function logOutAndLoginAndSynchronizeFriendsWithDb(callback){
  logOutAndLogin(null, function(){
    synchronizeFriendsWithDb(callback);
  });
}

function synchronizeFriendsWithDb(callback){
  getFrendIds(function(response){
    synchronizeUsersWithDb(response, callback)
  });
}

function getFrendIds(callback){
  application.secondaryLog('Делаем запрос на получение ids друзей пользователя <strong>' + global.current_user.user_id + '</strong>');

  VK.request('friends.get',
    {
      access_token: global.current_user.access_token
    },
    function(error, response){
      if(error){
        vkMethodRequestError(error, 'Произошла ошибка получения ids друзей пользователя <strong>' + global.current_user.user_id + '</strong>');

      } else {
        application.secondaryLog('Получение ids друзей пользователя <strong>' + global.current_user.user_id + '</strong> прошло успешно.');

        _.extend(global.current_user, {friend_ids: response});

        callback(response);
      }
    }
  );
}

function parseGroupsForAddingMembersToFriends(callback){
  application.secondaryLog('Запускаем парсинг групп');

  var onGroupMembersReceived = function(response, count){
    filterByDb(response.users, function(user_ids){
      setTimeout(function(){
        getUsers(user_ids, function(users){
          var online_users = _.where(users, {online: 1});

          application.secondaryLog('Online участников <strong>' + online_users.length + '</strong>');

          if(online_users.length > 0){
            var online_user_ids = _.map(online_users, function(u){return u.uid});

            addToFriends(online_user_ids, function(){
              if(response.count > response.offset){

                setTimeout(function(){
                  getGroupMembers(global.current_group, count, response.offset, onGroupMembersReceived);
                }, get_group_members_timout);

              } else {
                application.primaryLog('Все участники группы обработаны.');

                selectAndRunGroup(); // Здесь другую группу надо выбрать
              }
            });

          } else {
            application.secondaryLog('Получение следующих участников группы <strong>' + global.current_group + '</strong>...');

            setTimeout(function(){
              getGroupMembers(global.current_group, count, response.offset, onGroupMembersReceived);
            }, get_group_members_timout);
          }

        });
      }, get_users_timeout);

    });
  }

  var selectAndRunGroup = function (){
    global.current_group = global.groups[queue_group];

    queue_group += 1

    if(global.current_group) {
      getGroupMembers(global.current_group, 100, 0, onGroupMembersReceived);

    } else {
      application.secondaryLog('Все группы обработаны');

      callback();
    }
  }

  selectAndRunGroup();
}

function addToFriends(users, callback){
  var user;
  var db_users = db.collection('users');
  var user_queue = 0;

  var selectUser = function(){
    var user_id = users[user_queue];

    user_queue += 1;

    return user_id;
  }

  var addToFriend = function(user_id){
    application.secondaryLog('Идет добавление пользователя <strong>' + user_id + '</strong> в друзья...');

    VK.request('friends.add',
      {
        uid: user_id,
        access_token: global.current_user.access_token
      },
      function(error, response){
        if(error){

          if(error.code == 6) // Too many requests per second.
            throw error; // валим процесс до следующей отладки

          else if(error.error_code == 1 || error.error_code == 0){
            // превышен лими добавления в друзья вызодим из пользователя

            application.secondaryLog('Превышен лимит на добавления в друзья!');

            // здесь мы должны авторизовать нового пользователя и продолжить
            logOutAndLoginAndSynchronizeFriendsWithDb(function(){
              application.secondaryLog("Процесс продолжиться через " + add_to_frends_next_timeout / 60000 + " минут.");

              setTimeout(function(){
                next();
              }, add_to_frends_next_timeout);
            });

          } else if(error.error_code == 14){
            application.secondaryLog('Пришла капча на добавление пользователя <strong>' + user_id + '</strong> в друзья');

            application.secondaryLog("<img height='50' src='" + error.captcha_img+ "' />");

            increaseAndCheckCaptcha();

          } else {
            application.secondaryLog(error.error_msg);
            application.secondaryLog(util.inspect(error));
          }

        } else {
          global.added_users += 1;

          application.renderSidebar();

          db_users.insert({_id: user_id}, function(err, objects){
            if (err) application.secondaryLog(err.message);

            application.secondaryLog('Добавлен новый пользователь в базу данных.');

            next(); // далеем добавляем следующего пользователя
          });
        }
      }
    );
  }

  var increaseAndCheckCaptcha = function(){
    if(global.current_user.captcha_count){
      global.current_user.captcha_count += 1;
    } else {
      global.current_user.captcha_count = 1;
    }

    application.renderSidebar();

    // здесь мы должны авторизовать нового пользователя и продолжить
    if(global.current_user.captcha_count >= captcha_limit){
      application.secondaryLog('Превышен лимит капчи.');

      logOutAndLoginAndSynchronizeFriendsWithDb(function(){
        application.secondaryLog("Процесс продолжиться через " + add_to_frends_next_timeout / 60000 + " минут.");

        setTimeout(function(){
          next();
        }, add_to_frends_next_timeout);
      });

    } else {
      next();
    }
  }

  var next = function(){
    var user_id = selectUser();

    application.secondaryLog("Обрабатывается очередь <strong>" + user_queue + "</strong>");

    if(user_id){
      application.secondaryLog("Ждем " + add_to_friends_timeout / 1000 + " секунд...");

      setTimeout(function(){
        addToFriend(user_id);
      }, add_to_friends_timeout);

    } else {
      // если нет больше пользователей вызываем колбек на получение новых пользователей
      application.secondaryLog("Очереди на добавления друзей все обработаны");

      callback();
    }
  }

  next();
}

function getUsers(user_ids, callback) {
  application.secondaryLog('Запрашиваем расширенную информации пользователей...');

  VK.request('users.get',
    {
      uids: user_ids.join(','),
      access_token: global.current_user.access_token,
      fields: 'online'
    },
    function(error, response){
      if(error){
        vkMethodRequestError(error, 'Произошла ошибка получения расширенной информации пользователей.');

      } else {
        application.secondaryLog('Получение расширенной информации пользователей прошло успешно.');

        callback(response);
      }
    }
  );
}

function synchronizeUsersWithDb(user_ids, callback){
  var db_users = db.collection('users');

  application.secondaryLog('Синхронизация полученных id пользователей с базой данной...');

  filterByDb(user_ids, function(user_ids){
    db_users.insert(
    _.map(user_ids, function(id){ return {_id: id} }),
      function(error, objects){
        // /duplicate key error index/.test(error)
        if (error){
          if(/contains no documents/.test(error.message)) {
            application.secondaryLog('Нет данных для добавления в базу данных. ' + error.message);

          } else {
            // В любых других ситуация пока валим процесс до отладки
            throw error;
          }
        }

        application.secondaryLog('Синхронизация полученных id пользователей с базой данной завершена');

        callback();
      }
    );
  });
}

function filterByDb(user_ids, callback){
  var db_users = db.collection('users');
  var db_user_ids;
  var filtered_user_ids = [];

  db_users.find({_id: {$in: user_ids}}).toArray(function(err, objects){
    if(err) throw err;

    db_user_ids = _.map(objects, function(o){ return o._id });

    user_ids.forEach(function(id){
      if(!_.contains(db_user_ids, id)){
        filtered_user_ids.push(id);
      }
    });

    callback(filtered_user_ids);
  });
}

function connectToDb(callback){
  application.primaryLog('Подключаемся к базе данных...');

  MongoClient.connect('mongodb://127.0.0.1:27017/spammerdb', function(err, db) {
    if(err) throw err;

    callback(err, db);
  });
}

function vkLogin(callback){
  var auth_data_item = global.authorization_data[queue_authorization];

  if(!auth_data_item) {
    application.secondaryLog('Пользователи все обработаны');

    db.close();

    application.secondaryLog('Назначаем перезапуск программы через ' + restart_timeout / 60000 + ' минут');

    queue_authorization = 0; // сбрасываем очередь
    queue_group = 0; // сбрасываем очередь

    setTimeout(function(){
      step1();
    }, restart_timeout);

    return;
  }

  var login = auth_data_item[1];
  var pass  = auth_data_item[2];

  queue_authorization += 1 // сдвигаем на следующего пользователя для авторизации

  application.primaryLog('Идет авторизация пользователя <strong>' + auth_data_item[0] + '</strong>...');

  VK.authorize(login, pass, function(error, response){
    if(error) throw error.message;

    _.extend(global.current_user, response); // обновляем данные пользователя

    application.renderSidebar();

    application.primaryLog('Пользователь <strong>' + global.current_user.user_id + '</strong> авторизовался успешно.');

    callback(response);
  });
}

function vkLogout(callback){
  application.secondaryLog('Идет предварительный выход текущего участника...');

  VK.logOut(function(error, response){
    if(error) throw error;

    application.secondaryLog('Выход текущего участника выполнен успешно.');

    global.current_user = {} // обнуление участника

    application.renderSidebar();

    callback();
  });
}

// метод для вывода стандартных ошибок на запросы в Вконтакте
function vkMethodRequestError(error, message){
  application.secondaryLog(message);
  application.secondaryLog(error.error_msg);
  application.secondaryLog(util.inspect(error));
}


module.exports = Spammer;